Q: How do you write programs that are maintainable, readable, and adaptable? Especially consider your work on the CRUD Python module from Project One, which you used to connect the dashboard widgets to the database in Project Two. What were the advantages of working in this way? How else could you use this CRUD Python module in the future?

A: By breaking down projects into smaller pieces that are more generic and ambiguous that allows us to reuse these bits of code in other projects.  The CRUD module is a great example of an ambiguous piece of code that can be readily adapted to other projects with little to no effort.  By using easily identifiable variables and function names anyone that uses this module in the future will understand how it works and what it accomplishes. 

Q: How do you approach a problem as a computer scientist? Consider how you approached the database or dashboard requirements that Grazioso Salvare requested. How did your approach to this project differ from previous assignments in other courses? What techniques or strategies would you use in the future to create databases to meet other client requests?

A: I approached this project in a similar fashion to how I approach most of my projects and that is by dissecting it and breaking it down into smaller and smaller problems.  I then take each individual problem and attempt to solve them, for example the initial displaying of the database.  Once I know that my code functions correctly and the I can get this module to appear correctly I move on to the next piece.  I would say my approach is similar to unit testing in a way.  I make sure each individual piece functions properly first and then I put them together, seeing if any piece negatively interacts with the project as a whole, then working from there to remedy any issues.

Q: What do computer scientists do, and why does it matter? How would your work on this type of project help a company, like Grazioso Salvare, to do their work better?

A: Computer scientists use computers and computer programming to automate complex tasks, allowing for repeatability and efficiency.  When we take a task that would normally take much time and effort and automate it or create repeatable functions for it, we increase productivity and efficiency, but also reliability in that we know the task will be completed successfully each and every time.
